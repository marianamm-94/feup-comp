PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n" | <"/*">
    |  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >              // 1 line comment
    |  < "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/" > // multiple lines comment
;
TOKEN :
	< INTEGER : (["0" - "9"])+ > |

	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< AND : "&&" > |
	< LESS : "<" > |
	< EQUAL : "=" > |

	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_BRACE : "{" > |
	< CLOSE_BRACE : "}" > |
	< FULLSTOP : "." > |
	< SEMI_COLON : ";" > |
	< COLON : "," > |
	< OPEN_BRACKET : "[" > |
	< CLOSE_BRACKET : "]" > |
	< EXCLAMATION_MARK : "!" > |

	< IMPORT : "import" > |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< RETURN : "return" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< STRING : "String" > |
	< INT : "int" > |
	< BOOLEAN : "boolean" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< LENGTH : "length" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< THIS : "this" > |
	< NEW : "new" > |

	<IDENTIFIER: ["a"-"z","A"-"Z","_","$"](["a"-"z","A"-"Z","0"-"9","_","$"])*>
;

Program : ImportDeclaration ClassDeclaration <EOF> ;

ImportDeclaration:
	(<IMPORT> <IDENTIFIER> (<FULLSTOP> <IDENTIFIER>)* <SEMI_COLON>)*
;

ClassDeclaration: 
	<CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <OPEN_BRACE> (VarDeclaration)* (MethodDeclaration)* <CLOSE_BRACE> 
;

VarDeclaration:
	Type <IDENTIFIER> <SEMI_COLON>
;

MethodDeclaration:
	<PUBLIC> ( MainDeclaration| OtherMethodDeclaration )
;

MainDeclaration:
	<STATIC> <VOID> <MAIN> <OPEN_PAREN> <STRING> <OPEN_BRACKET> <CLOSE_BRACKET> <IDENTIFIER> <CLOSE_PAREN>
	<OPEN_BRACE> MethodBody <CLOSE_BRACE>
;

OtherMethodDeclaration:
	Type <IDENTIFIER> <OPEN_PAREN> (Type <IDENTIFIER> (<COLON> Type <IDENTIFIER>)*)? <CLOSE_PAREN>
	<OPEN_BRACE> MethodBody <RETURN> ExpressionAnd <SEMI_COLON> <CLOSE_BRACE>
;


MethodBody:
	(SCAN 2 VarDeclaration)* (Statement)*
;

Type: 
	<INT> (<OPEN_BRACKET> <CLOSE_BRACKET>)? | <BOOLEAN> | <IDENTIFIER>
;


Statement:
	<OPEN_BRACE> (Statement)* <CLOSE_BRACE> 
	| IfStatement
	| WhileStatement
	|  ExpressionAnd (<EQUAL> ExpressionAnd)? <SEMI_COLON> 
;

IfStatement:
	 <IF> <OPEN_PAREN> ExpressionAnd <CLOSE_PAREN> Statement <ELSE> Statement
;
WhileStatement:
	<WHILE> <OPEN_PAREN> ExpressionAnd <CLOSE_PAREN> Statement
;

ExpressionAnd:
	ExpressionLess (<AND> ExpressionLess)*
;
ExpressionLess:
	ExpressionAddOrSub (<LESS> ExpressionAddOrSub)*
;

ExpressionAddOrSub:
	ExpressionMultiOrDiv(
		<PLUS> ExpressionMultiOrDiv |
		<MINUS> ExpressionMultiOrDiv
	)*
;

ExpressionMultiOrDiv:
	ExpressionArray(
		<TIMES> ExpressionArray |
		<DIVIDE> ExpressionArray
	)*
;

ExpressionArray:
	ExpressionExclamation (Array)?
;

Array:
	<OPEN_BRACKET> ExpressionAnd <CLOSE_BRACKET>
;
ExpressionExclamation:
	ExpressionFullStop | <EXCLAMATION_MARK> ExpressionExclamation 
;

ExpressionFullStop:
	ExpressionEnd (<FULLSTOP> (<LENGTH> | ExpressionIdentifier) )*
;

ExpressionIdentifier:
	<IDENTIFIER> <OPEN_PAREN> (Parameter)? <CLOSE_PAREN>
;
Parameter:
	ExpressionAnd (<COLON> ExpressionAnd)*
;
ExpressionEnd:
	<INTEGER> 
	|<TRUE>
	| <FALSE>
	| <IDENTIFIER>
	| <THIS>
	| <OPEN_PAREN> ExpressionAnd <CLOSE_PAREN>
	| <NEW> (<INT> Array | <IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN>)
;







  

