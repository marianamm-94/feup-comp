PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n" | <"/*">;

TOKEN :
	< INTEGER : (["0" - "9"])+ > |

	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< AND : "&&" > |
	< LESS : "<" > |
	< EQUAL : "=" > |

	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_BRACE : "{" > |
	< CLOSE_BRACE : "}" > |
	< FULLSTOP : "." > |
	< SEMI_COLON : ";" > |
	< COLON : "," > |
	< OPEN_BRACKET : "[" > |
	< CLOSE_BRACKET : "]" > |
	< EXCLAMATION_MARK : "!" > |

	< IMPORT : "import" > |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< RETURN : "return" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< STRING : "String" > |
	< INT : "int" > |
	< BOOLEAN : "boolean" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< LENGTH : "length" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< THIS : "this" > |
	< NEW : "new" > |

	<IDENTIFIER : ["A" - "Z", "a"-"z"] (["0"-"9","A" - "Z", "a"-"z"])*>
;

Program : ImportDeclaration ClassDeclaration <EOF> ;

ImportDeclaration:
	(<IMPORT> <IDENTIFIER> (<FULLSTOP> <IDENTIFIER>)* <SEMI_COLON>)*
;

ClassDeclaration: 
	<CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <OPEN_BRACE> (VarDeclaration)* (MethodDeclaration)* <CLOSE_BRACE> 
;

VarDeclaration:
	Type <IDENTIFIER> <SEMI_COLON>
;

MethodDeclaration:
	<PUBLIC> Type <IDENTIFIER> <OPEN_PAREN> (Type <IDENTIFIER> (<COLON> Type <IDENTIFIER>)*)? <CLOSE_PAREN>
	<OPEN_BRACE> MethodBody <RETURN> Expression <SEMI_COLON> <CLOSE_BRACE>
	| <PUBLIC> <STATIC> <VOID> <MAIN> <OPEN_PAREN> <STRING> <OPEN_BRACKET> <CLOSE_BRACKET> <IDENTIFIER> <CLOSE_PAREN>
	<OPEN_BRACE> MethodBody <CLOSE_BRACE>
;

MethodBody:
	(SCAN 2 VarDeclaration)* (Statement)*
;

Type: 
	<INT> (<OPEN_BRACKET> <CLOSE_BRACKET>)? | <BOOLEAN> | <IDENTIFIER>
;


Statement:
	<OPEN_BRACE> (Statement)* <CLOSE_BRACE> 
	| ifStatement
	| ExpressionAnd [<EQUAL> ExpressionAnd]  <SEMI_COLON> 
;

ifStatement:
	( <IF> <OPEN_PAREN> ExpressionAnd <CLOSE_PAREN> Statement)
	<ELSE> Statement
;


ExpressionAnd:
	ExpressionLess (<AND> ExpressionLess)*
;
ExpressionLess:
	ExpressionAddOrSub (<LESS> ExpressionAddOrSub)*
;

ExpressionAddOrSub:
	ExpressionMultiOrDiv(
		<PLUS> ExpressionMultiOrDiv |
		<MINUS> ExpressionMultiOrDiv
	)*
;

ExpressionMultiOrDiv:
	ExpressionArray(
		<TIMES> ExpressionArray |
		<DIVIDE> ExpressionArray
	)*
;

ExpressionArray:
	ExpressionExclamation Array
;

Array:
	[ExpressionAnd]
;
ExpressionExclamation:
	ExpressionFullStop | <EXCLAMATION_MARK> ExpressionExclamation 
;

ExpressionFullStop:
	Expression (<FULLSTOP> (<LENGTH> | ExpressionIdentifier) )*
;

ExpressionIdentifier:
	<IDENTIFIER> <OPEN_PAREN> (Parameter)? <CLOSE_PAREN>
;
Parameter:
	ExpressionAnd (<SEMI_COLON> ExpressionAnd)*
;
Expression:
	<INTEGER> 
	|<TRUE>
	| <FALSE>
	| <IDENTIFIER>
	| <THIS>
	| <NEW> (<INT> Array | <IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN>)
;







  

